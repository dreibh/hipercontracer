#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
#  =================================================================
#           #     #                 #     #
#           ##    #   ####   #####  ##    #  ######   #####
#           # #   #  #    #  #    # # #   #  #          #
#           #  #  #  #    #  #    # #  #  #  #####      #
#           #   # #  #    #  #####  #   # #  #          #
#           #    ##  #    #  #   #  #    ##  #          #
#           #     #   ####   #    # #     #  ######     #
#
#        ---   The NorNet Testbed for Multi-Homed Systems  ---
#                        https://www.nntb.no
#  =================================================================
#
#  High-Performance Connectivity Tracer (HiPerConTracer)
#  Copyright (C) 2015-2018 by Thomas Dreibholz
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Contact: dreibh@simula.no

import os
import sys
import io
import datetime
import bz2
import shutil
import psycopg2
import configparser
import operator
from ipaddress import ip_address


# ###### Print log message ##################################################
def log(logstring):
   print('\x1b[32m' + datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S') + ': ' + logstring + '\x1b[0m');


# ###### Abort with error ###################################################
def error(logstring):
   sys.stderr.write(datetime.datetime.now().isoformat() + \
                    ' ===== ERROR: ' + logstring + ' =====\n')
   sys.exit(1)


# ###### Read input and prepare output ######################################

# Input types:
IT_NONE       = 0
IT_PING       = 1
IT_TRACEROUTE = 2

# Output types:
OT_POSTGRES   = 1
OT_MONGODB    = 2

def processInput(inputFile, outputType):
   inputType  = IT_NONE
   lineNumber = 0
   output     = {}
   for inputLine in inputFile.readlines():
      lineNumber = lineNumber + 1
      tuples = inputLine.rstrip().split(' ')
      if len(tuples) > 0:
         # ====== Ping ======================================================
         if tuples[0] == '#P':
            if len(tuples) >= 6:
               # ------ Handle input ----------------------------------------
               if inputType == IT_NONE:
                  inputType = IT_PING
               elif inputType != IT_PING:
                  raise Exception('Multiple input types in the same file?!')

               sourceIP      = ip_address(tuples[1])
               destinationIP = ip_address(tuples[2])
               timeStamp     = int(tuples[3], 16)
               status        = int(tuples[4])
               rtt           = int(tuples[5])

               assert ('0x' + tuples[3]) == hex(timeStamp)
               timeStampDT  = datetime.datetime(1970, 1, 1, 0, 0, 0, 0) +  datetime.timedelta(microseconds = timeStamp)
               timeStampStr = timeStampDT.strftime("%Y-%m-%dT%H:%M:%S.%f")
               # print('ping', sourceIP, destinationIP, timeStampStr, status, rtt)

               # ------ Generate output -------------------------------------
               if outputType == OT_POSTGRES:
                  output[str(sourceIP) + '-' + str(destinationIP) + '-' + str(timeStamp)] = '(' + \
                     '\'' + timeStampStr       + '\',' + \
                     '\'' + str(sourceIP)      + '\',' + \
                     '\'' + str(destinationIP) + '\',' + \
                     str(status) + ',' + \
                     str(rtt) + \
                     ')'

            else:
               raise Exception('Bad input for Ping in line ' + str(lineNumber))


         # ====== Traceroute ================================================
         elif tuples[0] == '#T':
            if len(tuples) >= 7:
               # ------ Handle input ----------------------------------------
               if inputType == IT_NONE:
                  inputType = IT_TRACEROUTE
               elif inputType != IT_TRACEROUTE:
                  raise Exception('Multiple input types in the same file?!')

               sourceIP      = ip_address(tuples[1])
               destinationIP = ip_address(tuples[2])
               timeStamp     = int(tuples[3], 16)
               roundNumber   = int(tuples[4])
               totalHops     = int(tuples[5])
               statusFlags   = int(tuples[6], 16)
               pathHashStr   = tuples[7]
               pathHash      = int(pathHashStr, 16)

               assert ('0x' + tuples[3]) == hex(timeStamp)
               assert ('0x' + tuples[6]) == hex(statusFlags)
               assert ('0x' + tuples[7]) == hex(pathHash)
               timeStampDT  = datetime.datetime(1970, 1, 1, 0, 0, 0, 0) +  datetime.timedelta(microseconds = timeStamp)
               timeStampStr = timeStampDT.strftime("%Y%m%dT%H%M%S.%f")
               # print('traceroute', sourceIP, destinationIP, timeStampStr, roundNumber, pathHash)

            else:
               raise Exception('Bad input for Traceroute in line ' + str(lineNumber))


         elif ((tuples[0] == '\t') and (inputType == IT_TRACEROUTE)):
            if len(tuples) >= 4:
               # ------ Handle input ----------------------------------------
               hopNumber = int(tuples[1])
               status    = int(tuples[2], 16)
               rtt       = int(tuples[3])
               hopIP     = ip_address(tuples[4])

               assert hopNumber <= totalHops
               assert ('0x' + tuples[2]) == hex(status)
               # print('\t', hopNumber, status, rtt, hopIP)

               # ------ Generate output -------------------------------------
               if outputType == OT_POSTGRES:
                  output[str(sourceIP) + '-' + str(destinationIP) + '-' + str(timeStamp) + '-' + str(roundNumber) + str(hopNumber)] = '(' + \
                     '\'' + timeStampStr       + '\',' + \
                     '\'' + str(sourceIP)      + '\',' + \
                     '\'' + str(destinationIP) + '\',' + \
                     str(hopNumber) + ',' + \
                     str(totalHops) + ',' + \
                     str(status) + ',' + \
                     str(rtt) + ',' + \
                     '\'' + str(hopIP) + '\',' + \
                     'CAST(X\'' + pathHashStr + '\' AS BIGINT),' + \
                     str(roundNumber) + \
                     ')'

            else:
               raise Exception('Bad input for Traceroute in line ' + str(lineNumber))

         # ====== Error =====================================================
         else:
            raise Exception('Unexpected input in line ' + str(lineNumber))


   # ====== Sort result =====================================================
   resultsList = sorted(output.items(), key=operator.itemgetter(0))

   # ====== Generate output string ==========================================
   outputString = ""
   if outputType == OT_POSTGRES:
      if inputType == IT_PING:
         outputString = 'INSERT INTO Ping VALUES '
      elif inputType == IT_TRACEROUTE:
         outputString = 'INSERT INTO Traceroute VALUES '

      firstItem = True
      for result in resultsList:
         if firstItem:
            outputString = outputString + '\n' + result[1]
            firstItem = False
         else:
            outputString = outputString + ',\n' + result[1]

      outputString = outputString + ';'

   # print(outputString)
   return outputString



# ###### Main program #######################################################
if len(sys.argv) < 2:
   error('Usage: ' + sys.argv[0] + ' database_configuration [-verbose]')

configFileName   = sys.argv[1]
transactionsPath = None
badFilePath      = None
dbServer         = 'localhost'
dbPort           = 5432
dbUser           = 'importer'
dbPassword       = None
dbName           = 'pingtraceroutedb'
verboseMode      = False

i = 2
while i < len(sys.argv):
   if sys.argv[i] == '-verbose':
      verboseMode = True
   else:
      error('Bad argument: ' + sys.argv[i])
   i = i + 1


# ====== Get parameters =====================================================
parsedConfigFile = configparser.RawConfigParser()
parsedConfigFile.optionxform = str   # Make it case-sensitive!
try:
   parsedConfigFile.readfp(io.StringIO('[root]\n' + open(configFileName, 'r').read()))
except Exception as e:
    error('Unable to read database configuration file' +  sys.argv[1] + ': ' + str(e))
    sys.exit(1)

for parameterName in parsedConfigFile.options('root'):
   parameterValue = parsedConfigFile.get('root', parameterName)
   if parameterName == 'transactions_path':
      transactionsPath = parameterValue
   elif parameterName == 'bad_file_path':
      badFilePath = parameterValue
   elif parameterName == 'dbserver':
      dbServer = parameterValue
   elif parameterName == 'dbport':
      dbPort = parameterValue
   elif parameterName == 'dbuser':
      dbUser = parameterValue
   elif parameterName == 'dbpassword':
      dbPassword = parameterValue
   elif parameterName == 'database':
      dbName = parameterValue
   else:
      error('Unknown parameter ' + parameterName + ' in ' + sys.argv[1] + '!')

if not os.path.exists(transactionsPath):
   error('Invalid transactions path: ' + transactionsPath + '!')
try:
   os.mkdir(badFilePath)
except:
   pass
if not os.path.exists(badFilePath):
   error('Invalid bad file path: ' + badFilePath + '!')


# ====== Connect to the database ============================================
try:
   dbConnection = psycopg2.connect(host=str(dbServer), port=str(dbPort),
                                   user=str(dbUser), password=str(dbPassword),
                                   dbname=str(dbName))
   dbConnection.autocommit = False
except:
    log('Unable to connect to the database!')
    sys.exit(1)

dbCursor = dbConnection.cursor()


# ====== Import transactions ================================================
fileNumber       = 0
goodTransactions = 0
badTransactions  = 0
firstTransaction = True

transactionFileList = sorted([ file for file in os.listdir(transactionsPath) if os.path.isfile(os.path.join(transactionsPath, file)) ])
for transactionFile in transactionFileList:
   absTransactionFile = os.path.join(transactionsPath, transactionFile)
   if os.path.isfile(absTransactionFile):
      if firstTransaction:
         firstTransaction = False
         log('Starting import of new transactions ...')

      # ------ Read transactions from file ----------------------------------
      fileNumber = fileNumber + 1
      if verboseMode == True:
         log('Importing ' + absTransactionFile +
             ' (' + str(fileNumber) + ' of ' + str(len(transactionFileList)) + ') ...')

      transactionContent = None
      try:
         inputFile = bz2.open(absTransactionFile, 'rt')
         transactionContent = processInput(inputFile, OT_POSTGRES)
      except Exception as e:
         log('Transaction ' + transactionFile + ' cannot be read: ' + str(e) + ' -> moving it to bad file directory')
         try:
            shutil.move(absTransactionFile, badFilePath)
         except Exception as e:
            error('Unable to move bad transaction ' + absTransactionFile + ' to ' + badFilePath + ': ' + str(e))

      if transactionContent != None:
         # ------ Commit transactions ---------------------------------------
         try:
            # print(transactionContent)
            dbCursor.execute(transactionContent)
            dbConnection.commit()
            goodTransactions = goodTransactions + 1

         # ------ Handle exceptions -> rollback -----------------------------
         except Exception as e:
            # ------ Connection is broken -----------------------------------
            if ( (dbConnection.closed) or
                 ("SSL SYSCALL error" in str(e)) ):
               # Need to check for "SSL SYSCALL errors", since psycopg2
               # does not detect connection breaks properly.
               # See https://bitbucket.org/zzzeek/sqlalchemy/issues/3021/ssl-eof-not-detected-as-disconnect-in
               log('The database connection seems to be closed. Aborting import!')
               break

            # ------ Other problem (e.g. bad SQL statements, etc. -----------
            log('Transaction ' + transactionFile + ' cannot be committed: ' + str(e) + ' -> moving it to bad file directory')
            dbConnection.rollback()
            try:
               shutil.move(absTransactionFile, badFilePath)
            except Exception as e:
               error('Unable to move bad transaction ' + absTransactionFile + ' to ' + badFilePath + ': ' + str(e))
            badTransactions = badTransactions + 1

      try:
         if os.path.exists(absTransactionFile):
            os.remove(absTransactionFile)
      except Exception as e:
         error('Unable to remove completed transaction ' + absTransactionFile + ': ' + str(e))


# ====== All done! ==========================================================
log(str(goodTransactions) + ' transactions committed, ' + str(badTransactions) + ' were bad.')
